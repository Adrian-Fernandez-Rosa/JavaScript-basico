 MODULOS JS
 
    MÓDULOS ES6

   > JS siempre ha tenido el problema de la organización del código, sobre todo en aplicaciones grandes.
   > Siempre se nos llenaban los archivos js de funciones y clases para organizar mejor el código de nuestras aplicaciones.
   
   > Pero tener todo en un fichero es poco eficiente, la mayoría de los lenguajes de programación se organizan en módulos,
     o sistemas modulares para organizar la información.
   > Vimos en el curso CSS como SaSS nos ayudaba a organizar modularmente los archivos .scss que posteriormente se compilaban
     en un solo .css.
   > En el lado del cliente esto se "solucionaba" con llamadas a sucesivos archivos .js pero con el problema de ser poco 
     eficiente, sobrecargar al servidor y tener cuidado con el orden de carga.
   > En ECMAScript ES6 aparecen los módulos ES o ESM, que permiten exportar e importar datos entre distintos ficheros de JS,
     con las palabras claves.
	
	//ANALIZAR ARCHIVO LINEA 57

     > export
       Exporta datos (variables, funciones, clases...)
       del fichero actual hacia otros que lo importen.

     > import
      Importa datos (variables, funciones, clases...) dede un .js al que lo solicita.

      EJEMPLO:
      > Creamos un fichero exporta.js.
      > ojo ponemos type: module en el package.json.


*/

// Ejemplo 1
   // import { numero } from "./exporta.js";
  /*   
  import { numero, miFuncion } from "./exporta.js"; //entre llaves elementos y propiedades para importar
    console.log(numero);
    console.log(miFuncion());
 */

//EJEMPLO IMPORTACION POR DEFECTO.
    import miImportacione from "./exporta.js"; //notar que en el archivo exporta no esta la referencia miImportacione 
    //se le puede poner cualquier nombre debido a
    //const porDefecto = () => "Soy la función por defecto."
    //export { porDefecto as default}; 
    console.log(miImportacione())

    // IMPORTACION TOTAL DE LO QUE EL OTRO ARCHIVO EXPORTA
    import * as miImportacion from './exporta.js';
    console.log(miImportacion.saludar());
    console.log(miImportacion.despedir());
    // y a la por defecto
    console.log(miImportacion.default());
 
 --------------------------------------------------------- 
 
 ARCHIVO EXPORTA.JS
export const numero = 1256;
 export const miFuncion = () => 'hola';


 
 let nombre = 'Adrian';
 const saludar = () => "¡Hola!";
 const goodbye = () => "¡Adios!";
 const porDefecto = () => "Soy la función por defecto."

export { nombre };  //Se crea un módulo y se añade number.
export { saludar, goodbye as despedir}; // Se añade saludar y despedir al módulo.
export { porDefecto as default};  //se añade Clase al módulo (default) //corregir este comentario luego

----------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------
 
 
 
* Trabajando con módulos
  * ¿Qué es un módulo?
  * Haciendo uso de require para importar
  * Usando import y export como solución actual
  * Diferencia de importación entre export y export default

* Trabajando con librerías
  * ¿Qué es una librería?

    En informática, una biblioteca , es un conjunto de implementaciones funcionales, codificadas en un lenguaje de programación, 
    que ofrece una interfaz bien definida para la funcionalidad que se invoca.

    Las librerías son fundamentales nos permiten aprovechar el código de otros desarrolladores
    En nodeJS a las librerías se les llama "paquetes"
    El gestor de paquetes es npm

  * Instalando librerías externas a través de npm
  * Haciendo uso de librerías presentes entre node_modules

Las librerías o paquetes las instalamos con

npm install <nombre del paquete> (local para un proyecto)
npm install -g <nombre del paquete> (global, accesible por todos los proyectos)
npm install express

El archivo package.json se actualiza con las dependencias
Creamos el paquete con npm init

Cuando queremos instalar una dependencia necesaria en ejecucion
npm install --save express

Si fuese una dependencia de desarrollo sería
npm install --save-dev <nombre del paquete>

https://www.npmjs.com/package/express

Vamos a ver y a instalar express, que es la librería que nos permite hacer aplicaciones webs
Creamos app.js
>> seguimos en app.js

//ojo para matar un puerto npx kill-port 3000

  * Librerías externas de interés
  https://profile.es/blog/librerias-javascript/
 
 --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	class Ave {}

const gallina =new Ave() */

/* class Persona{
    saludo() { return "Hola"}
}

const carlos = new Persona;

console.log(carlos.saludo());


class Coche {
    constructor(a, b) { //se llama asi el constructor de js
        this.propiedad1 = a;
        this.propiedad2 = b;
    }
    metodoo(){
        console.log(this.propiedad1 + this.propiedad2)
    }
}

miCoche = new Coche(1,2);

miCoche.metodoo();

*/

// Los métodos static son accesibles desde la clase.
// Ejemplos static

 /*    class Persona { 
        constructor() {
            console.log("Hemos creado una nueva persona");
            this.nacionalidad = "Sin definirr";
        }
            saludo() { return "Hola/Hello"}
        
            static tipo() { // Los métodos static siempre accesibles sin new();

                return "Soy una persona";
            }
    }

    console.log(Persona.tipo());

    const Carlos = new Persona;
    Carlos.saludo();
    console.log(Carlos.nacionalidad);
  Carlos.tipo();  //error los métodos static no son para objetos
  Carlos.nacionalidad ="España"
  console.log(Carlos.nacionalidad); //ya que tiene this */


  // Podemos definir propiedades fuera del constructor

/*     class Persona {
        pelo = 'negro'
        constructor() {
            console.log("Persona creada")
        }
    }

    const carlos = new Persona;

    console.log( carlos.pelo)
    carlos.pelo="rubio"
    console.log(carlos.pelo) */

    // PROPIEDADES Y METODOS PRIVADOS

    class Persona {
        #id = 'person' //propiedad privada
        constructor(){
            console.log("persona creada")
        }
        #dameid() { return this.#id} //metodo privado
        idpublico() { return this.#dameid()}
    }

    const carlos = new Persona

    console.log(carlos.idpublico())
    console.log(carlos.idpublico())
	--------------------------------------------------------------------------------------------------------------------------------
	--------------------------------------------------------------------------------------------------------------------------------
	--------------------------------------------------------------------------------------------------------------------------------
	  // ÁMBITOS CLASE Y MÉTODO.

    /*
    Tenemos el ámbito de método, las variables declaradas dentro del método seran accesibles
    solo en el método, mientras que "this" es accesible a nivel de clase

    */
/* 
    class Coche {
        constructor() {
          //const tipo = "Sedan";
          this.tipo = "Ranchera"
          console.log("Mi tipo de coche es " + this.tipo);
        }
        arranca(a) {
          //let llave = a
          this.llave = a
          console.log(`En marcha con ${this.llave}!`) 
        }
        dameTipo() {
         // console.log(`El tipo es: ${this.tipo} y tiene ${llave}`);
          console.log(`El tipo es: ${this.tipo} y tiene ${this.llave}`);
          console.log(`El tipo es: ${this.tipo} `);
        }
      }

      const miCoche = new Coche(); 
     console.log( miCoche.tipo)
      miCoche.arranca(1)
      miCoche.dameTipo()

      console.log(miCoche.llave)
 */
      // GETTER
 /*      class Coche {
        constructor(n) {
          this.tipo = n;
        }
        get miTipo() {
          return "Mi coche es de tipo " + this.tipo;
        }
      }
      const miCoche = new Coche("Gasolina");
     // miCoche
      miCoche.miTipo

      // esto no funciona veremos los setters
      const coche = new Coche(1);
      console.log(coche.tipo) */


         // #############################  Setters 
      // mismo concepto de getters (get) pero esta vez para stablecer información

         // Ejemplo de setters

  /*      
           class Coche {
              constructor(n) {
                this._tipo = n;
              }
              get miTipo() {
                return "Mi coche es de tipo " + this._tipo;
              }
              set miTipo(n) {
                this._tipo = n;
              }
            }

            const miCoche = new Coche("Gasolina");
            //miCoche
            miCoche.miTipo
            miCoche.miTipo = "Diésel"
            miCoche.miTipo
        */
	------------------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------------------
            
        // ########## Herencia de clases
        // Con la herencia podemos establecer una "jerarquía" de elementos y reutilizar características dependiendo del nivel de cada elemento.
        // Desde ES6 podemos "extender" una clase 
		 // Ejemplo de herencia
          // Clase de primer nivel o padre

          class Automovil { // Clase Padre
            constructor() {
              this.marca
              console.log("Constructor de la clase padre Automovil.");
            }
            arrancar() {
              console.log("Vehículo en marcha!");
            }
          }


          class Coche extends Automovil {
            constructor() {
              super();
              console.log("Constructor de coche, heredado de padre");
            }
          }

          class Camion extends Automovil  {
            constructor(ruedas, tipo) {
              super();
              this.ruedas = ruedas
              this. tipo = tipo
              console.log(`Soy un camión de ${ruedas} ruedas y de tipo ${tipo}"`);
            }
          }


           const miCoche = new Coche()
        miCoche.arrancar()
        miCoche.marca = "Seat"
        miCoche.marca

        const miCamion = new Camion(8, 'Frigo')
        miCamion.arrancar()
		
	
	--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	  LINEA 1 :: MODULOS JS, EXPORTACION Y IMPORTACION ENTRE ARCHIVOS
	LINEA 126 ::  POO EN JS, METODOS ESTATICOS, GET SETTER EN LA 198, ATRIBUTOS PRIVADOS
	LINEA 214 :: AMBITO DE CLASE Y METODOS 
	LINEA 292 :: HERENCIA 